// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")  // pooled
  directUrl = env("DIRECT_URL")    // direct
}

// Keeping these enums for future use in code, but we are
// no longer tying them directly to DB columns.
enum ApplicationStage {
  APPLIED
  SCREENING
  HM_INTERVIEW
  PANEL
  OFFER
  HIRED
  REJECTED
}

enum ApplicationStatus {
  PENDING
  REVIEWING
  SHORTLISTED
  REJECTED
  HIRED
}

model Tenant {
  id          String @id @default(cuid())
  name        String
  slug        String @unique

  // Relations
  // NOTE: We removed the Job[] relation here because ATS jobs
  // now live in the `jobs` table managed via Supabase.
  clientCompanies ClientCompany[] @relation("TenantClientCompanies")
  candidates      Candidate[]     @relation("TenantCandidates")
  talentRequests  TalentRequest[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ClientCompany {
  id          String   @id @default(cuid())
  tenant      Tenant   @relation("TenantClientCompanies", fields: [tenantId], references: [id])
  tenantId    String

  name        String
  slug        String
  logoUrl     String?
  websiteUrl  String?
  location    String?
  industry    String?
  size        String?  // e.g. "11–50", "51–200"

  // We intentionally do NOT model a Prisma relation to Job here
  // because the ATS jobs live in the `jobs` table without a
  // client_company_id foreign key.

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Slug unique per tenant
  @@unique([tenantId, slug])
  @@index([tenantId])
}

// ─────────────────────────────────────────────────────────────
// Canonical ATS Job model → maps to Supabase `public.jobs`
// ─────────────────────────────────────────────────────────────

model Job {
  id              String    @id @db.Uuid
  tenantId        String    @db.Uuid           @map("tenant_id")
  externalId      String?   @db.Text           @map("external_id")
  title           String    @db.Text
  department      String?   @db.Text
  location        String?   @db.Text
  employmentType  String?   @db.Text           @map("employment_type")
  seniority       String?   @db.Text
  description     String?   @db.Text
  hiringManagerId String?   @db.Uuid           @map("hiring_manager_id")
  status          String    @db.Text
  visibility      String    @db.Text
  tags            String[]  @db.Text
  createdBy       String?   @db.Uuid           @map("created_by")
  createdAt       DateTime  @db.Timestamptz(6) @map("created_at")
  updatedAt       DateTime  @db.Timestamptz(6) @map("updated_at")
  slug            String?   @db.Text

  // One job → many applications (ATS pipeline)
  applications    JobApplication[]

  @@map("jobs")
  @@index([tenantId])
}

model Candidate {
  id                    String   @id @default(cuid())
  tenant                Tenant   @relation("TenantCandidates", fields: [tenantId], references: [id])
  tenantId              String

  fullName              String
  email                 String   @unique
  phone                 String?
  location              String?
  linkedinUrl           String?
  yearsOfExperience     Int?
  currentRole           String?
  currentCompany        String?
  primaryFunction       String?  // "Engineering", "Product", etc.
  seniority             String?  // "Junior", "Mid", "Senior"
  skills                String[] // e.g. ["Python", "SQL"]

  cvUrl                 String?  // latest uploaded CV URL
  notes                 String?  // internal notes

  // Auth / portal access
  loginToken            String?  @unique
  loginTokenExpiresAt   DateTime?

  // NOTE: We are not modeling a direct Prisma relation to JobApplication here
  // because the ATS applications live in `job_applications` with a candidate_id UUID.
  // Once that linkage is finalised to match Candidate.id in the DB, we can add
  // a safe relation.

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// ─────────────────────────────────────────────────────────────
// Canonical ATS JobApplication model → `public.job_applications`
// ─────────────────────────────────────────────────────────────

model JobApplication {
  id           String   @id @db.Uuid
  jobId        String   @db.Uuid           @map("job_id")
  candidateId  String?  @db.Uuid           @map("candidate_id")
  fullName     String   @db.Text           @map("full_name")
  email        String   @db.Text
  phone        String?  @db.Text
  location     String?  @db.Text
  linkedinUrl  String?  @db.Text           @map("linkedin_url")
  portfolioUrl String?  @db.Text           @map("portfolio_url")
  cvUrl        String?  @db.Text           @map("cv_url")
  coverLetter  String?  @db.Text           @map("cover_letter")
  source       String?  @db.Text
  stage        String   @db.Text
  status       String   @db.Text

  createdAt    DateTime @db.Timestamptz(6) @map("created_at")
  updatedAt    DateTime @db.Timestamptz(6) @map("updated_at")

  // One application belongs to a Job
  job          Job      @relation(fields: [jobId], references: [id])

  @@map("job_applications")
  @@index([jobId])
}

model TalentRequest {
  id             String   @id @default(cuid())
  tenant         Tenant   @relation(fields: [tenantId], references: [id])
  tenantId       String

  companyName    String
  contactName    String
  contactEmail   String
  contactPhone   String?

  roleTitle      String
  roleLevel      String?   // e.g. "Senior", "Manager"
  function       String?   // e.g. "Engineering", "Sales"
  location       String?
  workType       String?   // "Onsite", "Remote", "Hybrid"
  employmentType String?   // "Full-time", "Contract", etc.

  budgetCurrency String?   // "USD", "NGN", etc.
  budgetMin      Int?
  budgetMax      Int?
  hiresCount     Int?

  notes          String?
  status         String   @default("new")

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([tenantId])
}
