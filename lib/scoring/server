// lib/scoring/server.ts
import { prisma } from "@/lib/prisma";
import type {
  Candidate,
  Job,
  JobApplication,
  Tenant,
} from "@prisma/client";
import type {
  NormalizedScoringConfig,
  SemanticScoringResponse,
  ScoredApplicationView,
  Tier,
} from "./types";

const DEFAULT_SCORING_CONFIG: NormalizedScoringConfig = {
  hiringMode: "balanced",
  thresholds: {
    tierA: 80,
    tierB: 65,
    tierC: 50,
  },
  weights: {
    coreCompetencies: 30,
    experienceQuality: 25,
    education: 15,
    achievements: 15,
    culturalFit: 15,
  },
};

function clampNumber(
  value: unknown,
  fallback: number,
  min: number,
  max: number,
): number {
  const n =
    typeof value === "number" && Number.isFinite(value) ? value : fallback;
  return Math.min(max, Math.max(min, n));
}

function normalizeScoringConfig(raw: any): NormalizedScoringConfig {
  const hiringModeRaw = raw?.hiringMode;
  const hiringMode: NormalizedScoringConfig["hiringMode"] =
    hiringModeRaw === "volume" ||
    hiringModeRaw === "executive" ||
    hiringModeRaw === "balanced"
      ? hiringModeRaw
      : "balanced";

  const thresholdsRaw = raw?.thresholds ?? {};
  const weightsRaw = raw?.weights ?? {};

  return {
    hiringMode,
    thresholds: {
      tierA: clampNumber(thresholdsRaw.tierA, 80, 1, 100),
      tierB: clampNumber(thresholdsRaw.tierB, 65, 1, 100),
      tierC: clampNumber(thresholdsRaw.tierC, 50, 1, 100),
    },
    weights: {
      coreCompetencies: clampNumber(
        weightsRaw.coreCompetencies,
        30,
        0,
        100,
      ),
      experienceQuality: clampNumber(
        weightsRaw.experienceQuality,
        25,
        0,
        100,
      ),
      education: clampNumber(weightsRaw.education, 15, 0, 100),
      achievements: clampNumber(weightsRaw.achievements, 15, 0, 100),
      culturalFit: clampNumber(weightsRaw.culturalFit, 15, 0, 100),
    },
  };
}

export function mergeScoringConfig(opts: {
  tenantConfig: any;
  jobOverrides: any;
  tenantHiringMode: string | null;
  jobHiringMode: string | null;
}): NormalizedScoringConfig {
  const base: any = {
    ...DEFAULT_SCORING_CONFIG,
    ...(opts.tenantConfig ?? {}),
    ...(opts.jobOverrides ?? {}),
  };

  // Let job override hiringMode > tenant > default
  const hiringMode =
    opts.jobHiringMode || opts.tenantHiringMode || base.hiringMode;

  return normalizeScoringConfig({
    ...base,
    hiringMode,
  });
}

export async function getScoringConfigForJob(jobId: string): Promise<{
  job: Job & { tenant: Tenant };
  tenant: Tenant;
  config: NormalizedScoringConfig;
}> {
  const job = await prisma.job.findUnique({
    where: { id: jobId },
    include: {
      tenant: true,
    },
  });

  if (!job) {
    throw new Error(`Job not found for scoring: ${jobId}`);
  }

  const tenant = job.tenant;

  const config = mergeScoringConfig({
    tenantConfig: (tenant.scoringConfig as any) ?? null,
    jobOverrides: (job.scoringOverrides as any) ?? null,
    tenantHiringMode: tenant.hiringMode ?? null,
    jobHiringMode: job.hiringMode ?? null,
  });

  return { job, tenant, config };
}

function tierFromScore(
  score: number,
  thresholds: NormalizedScoringConfig["thresholds"],
): Tier {
  if (score >= thresholds.tierA) return "A";
  if (score >= thresholds.tierB) return "B";
  if (score >= thresholds.tierC) return "C";
  return "D";
}

async function callScoringService(opts: {
  tenant: Tenant;
  job: Job;
  candidate: Candidate | null;
  application: JobApplication;
  config: NormalizedScoringConfig;
}): Promise<SemanticScoringResponse> {
  const { tenant, job, candidate, application, config } = opts;

  const url = process.env.SCORING_SERVICE_URL;
  const apiKey = process.env.SCORING_SERVICE_API_KEY;

  if (!url || !apiKey) {
    // Best-practice: fail softly, but *log* so you catch env drift.
    console.warn(
      "[scoring] SCORING_SERVICE_URL or SCORING_SERVICE_API_KEY not configured â€“ returning neutral score.",
    );
    return {
      score: 0,
      reason: "Scoring service not configured.",
      risks: [],
      redFlags: [],
      interviewFocus: [],
    };
  }

  const controller = new AbortController();
  const timeoutMs = Number(process.env.SCORING_SERVICE_TIMEOUT_MS ?? "5000");
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      method: "POST",
      signal: controller.signal,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        tenant: {
          id: tenant.id,
          slug: tenant.slug,
          plan: tenant.plan,
          hiringMode: tenant.hiringMode,
        },
        job: {
          id: job.id,
          title: job.title,
          description: job.description,
          requiredSkills: job.requiredSkills,
          experienceLevel: job.experienceLevel,
          workMode: job.workMode,
          hiringMode: job.hiringMode,
        },
        candidate: candidate
          ? {
              id: candidate.id,
              fullName: candidate.fullName,
              email: candidate.email,
              location: candidate.location,
              currentTitle: candidate.currentTitle,
              currentCompany: candidate.currentCompany,
              cvUrl: candidate.cvUrl,
            }
          : null,
        application: {
          id: application.id,
          fullName: application.fullName,
          email: application.email,
          location: application.location,
          cvUrl: application.cvUrl,
          coverLetter: application.coverLetter,
          githubUrl: application.githubUrl,
          howHeard: application.howHeard,
          source: application.source,
        },
        config,
        context: {
          trigger: "application_created",
        },
      }),
    });

    if (!response.ok) {
      console.error(
        "[scoring] Service returned non-2xx:",
        response.status,
        await response.text().catch(() => ""),
      );
      return {
        score: 0,
        reason: `Scoring service error (${response.status})`,
        risks: [],
        redFlags: [],
        interviewFocus: [],
      };
    }

    const json = (await response.json()) as SemanticScoringResponse;

    if (typeof json.score !== "number" || !Number.isFinite(json.score)) {
      console.error("[scoring] Invalid score payload:", json);
      return {
        score: 0,
        reason: "Scoring service returned invalid payload.",
        risks: [],
        redFlags: [],
        interviewFocus: [],
      };
    }

    return json;
  } catch (err) {
    if ((err as any).name === "AbortError") {
      console.error("[scoring] Service timed out after", timeoutMs, "ms");
      return {
        score: 0,
        reason: "Scoring service timeout.",
        risks: [],
        redFlags: [],
        interviewFocus: [],
      };
    }

    console.error("[scoring] Unexpected error calling scoring service:", err);
    return {
      score: 0,
      reason: "Unexpected error calling scoring service.",
      risks: [],
      redFlags: [],
      interviewFocus: [],
    };
  } finally {
    clearTimeout(timeout);
  }
}

/**
 * Main hook for write-paths:
 * - Calls external scoring service
 * - Updates job_applications.match_score / match_reason
 * - Writes a scoring_events row for audit
 * - Returns a normalized ScoredApplicationView shape for callers (if needed)
 */
export async function scoreAndPersistApplication(
  applicationId: string,
): Promise<ScoredApplicationView | null> {
  const application = await prisma.jobApplication.findUnique({
    where: { id: applicationId },
    include: {
      job: {
        include: {
          tenant: true,
        },
      },
      candidate: true,
    },
  });

  if (!application) {
    console.warn("[scoring] Application not found for scoring:", applicationId);
    return null;
  }

  const job = application.job;
  const tenant = job.tenant;
  const candidate = application.candidate;

  const { config } = await getScoringConfigForJob(job.id);

  const semantic = await callScoringService({
    tenant,
    job,
    candidate,
    application,
    config,
  });

  const score = Math.round(
    Math.min(100, Math.max(0, semantic.score ?? 0)),
  );

  const tier: Tier =
    semantic.tier ??
    tierFromScore(score, config.thresholds);

  // Persist on the application itself
  await prisma.jobApplication.update({
    where: { id: application.id },
    data: {
      matchScore: score,
      matchReason:
        semantic.reason ??
        "Scored by semantic CV/JD engine.",
    },
  });

  // Write audit event
  await prisma.scoringEvent.create({
    data: {
      tenantId: tenant.id,
      jobId: job.id,
      applicationId: application.id,
      engine: semantic.engine || "semantic-external",
      engineVersion: semantic.engineVersion || null,
      mode: config.hiringMode,
      score,
      tier,
      configSnapshot: config as any,
      inputSummary: {
        hasCv: Boolean(application.cvUrl || candidate?.cvUrl),
        hasCoverLetter: Boolean(application.coverLetter),
        jobRequiredSkills: job.requiredSkills ?? [],
        source: application.source ?? null,
      },
      reason: semantic.reason ?? null,
      risks: semantic.risks ?? [],
      redFlags: semantic.redFlags ?? [],
    },
  });

  return {
    score,
    tier,
    risks: semantic.risks ?? [],
    redFlags: semantic.redFlags ?? [],
    interviewFocus: semantic.interviewFocus ?? [],
    reason:
      semantic.reason ??
      "Scored by semantic CV/JD engine.",
  };
}
